/* DO NOT EDIT THIS FILE - it is machine generated */
#include <com_ninadtech_imagecapture_OpenCVFunctions.h>

JNIEXPORT void JNICALL Java_com_ninadtech_imagecapture_OpenCVFunctions_hogueTransform
  (JNIEnv *, jclass, jlong addrRgba){
    Mat& originalImage = *(Mat*)addrRgba;
    detectAndDisplayCircles(originalImage);
  }

  void detectAndDisplayCircles(Mat& frame){
   Mat src_gray;


    if( !frame.data )
      { return ; }

    /// Convert it to gray
    cvtColor( frame, src_gray, CV_BGR2GRAY );

    /// Reduce the noise so we avoid false circle detection
    GaussianBlur( src_gray, src_gray, Size(9, 9), 2, 2 );

    vector<Vec3f> circles;

    /// Apply the Hough Transform to find the circles
    HoughCircles( src_gray, circles, CV_HOUGH_GRADIENT, 1, src_gray.rows/8, 200, 100, 0, 0 );

    /// Draw the circles detected
    for( size_t i = 0; i < circles.size(); i++ )
    {
        Point center(cvRound(circles[i][0]), cvRound(circles[i][1]));
        int radius = cvRound(circles[i][2]);
        // circle center
        circle( frame, center, 3, Scalar(0,255,0), -1, 8, 0 );
        // circle outline
        circle( frame, center, radius, Scalar(0,0,255), 3, 8, 0 );
        putText(frame,to_string(radius),center,FONT_HERSHEY_SCRIPT_SIMPLEX,1,Scalar(0,200,200), 4);
     }
  }


  string to_string(int value)
  {
      std::ostringstream os ;
      os << value ;
      return os.str() ;
  }

JNIEXPORT void JNICALL Java_com_ninadtech_imagecapture_OpenCVFunctions_convertToGray
  (JNIEnv *, jclass, jlong addrRgba, jlong addrGray){
    Mat& mRgba = *(Mat*)addrRgba;
    Mat& mGray = *(Mat*)addrGray;
    int conv;
    jint retVal;

    conv = toGray(mRgba,mGray);
    retVal = (jint)conv;

}
int toGray(Mat img, Mat& gray){
    cvtColor(img,gray, CV_RGBA2GRAY);
    if(gray.rows == img.rows && gray.cols == img.cols)
        return 1;
    return 0;
}

//detectBlobs
JNIEXPORT void JNICALL Java_com_ninadtech_imagecapture_OpenCVFunctions_detectBlobs
  (JNIEnv *, jclass, jlong addrRgba){
    Mat& originalImage = *(Mat*)addrRgba;
    Mat src_gray;


        if( !originalImage.data )
          { return ; }

        /// Convert it to gray
        cvtColor( originalImage, src_gray, CV_RGBA2GRAY );
        // Set up the detector with default parameters.
        SimpleBlobDetector detector;
        // Detect blobs.
        std::vector<KeyPoint> keypoints;
        detector.detect( src_gray, keypoints);

        // Draw detected blobs as red circles.
        // DrawMatchesFlags::DRAW_RICH_KEYPOINTS flag ensures the size of the circle corresponds to the size of blob

        drawKeypoints( src_gray, keypoints, originalImage, Scalar(0,0,255), DrawMatchesFlags::DRAW_RICH_KEYPOINTS );

  }